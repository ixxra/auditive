/* auditive.c generated by valac 0.20.1, the Vala compiler
 * generated from auditive.vala, do not modify */

/*

This file is part of Auditive.

Copyright 2010-2012 Graeme Sheppard.

Auditive is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Auditive is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Auditive. If not, see <http://www.gnu.org/licenses/>.

*/

#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>
#include <curses.h>
#include <gobject/gvaluecollector.h>


#define TYPE_AUDITIVE (auditive_get_type ())
#define AUDITIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AUDITIVE, auditive))
#define AUDITIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AUDITIVE, auditiveClass))
#define IS_AUDITIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AUDITIVE))
#define IS_AUDITIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AUDITIVE))
#define AUDITIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AUDITIVE, auditiveClass))

typedef struct _auditive auditive;
typedef struct _auditiveClass auditiveClass;
typedef struct _auditivePrivate auditivePrivate;

#define TYPE_WORLD_WIDE (world_wide_get_type ())
#define WORLD_WIDE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WORLD_WIDE, world_wide))
#define WORLD_WIDE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WORLD_WIDE, world_wideClass))
#define IS_WORLD_WIDE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WORLD_WIDE))
#define IS_WORLD_WIDE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WORLD_WIDE))
#define WORLD_WIDE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WORLD_WIDE, world_wideClass))

typedef struct _world_wide world_wide;
typedef struct _world_wideClass world_wideClass;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _world_widePrivate world_widePrivate;

#define TYPE_CONSOLE (console_get_type ())
#define CONSOLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONSOLE, console))
#define CONSOLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONSOLE, consoleClass))
#define IS_CONSOLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONSOLE))
#define IS_CONSOLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONSOLE))
#define CONSOLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONSOLE, consoleClass))

typedef struct _console console;
typedef struct _consoleClass consoleClass;

#define TYPE_SCREEN (screen_get_type ())
#define SCREEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCREEN, screen))
#define SCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCREEN, screenClass))
#define IS_SCREEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCREEN))
#define IS_SCREEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCREEN))
#define SCREEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCREEN, screenClass))

typedef struct _screen screen;
typedef struct _screenClass screenClass;

#define TYPE_PLAYLIST (playlist_get_type ())
#define PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYLIST, playlist))
#define PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYLIST, playlistClass))
#define IS_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYLIST))
#define IS_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYLIST))
#define PLAYLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYLIST, playlistClass))

typedef struct _playlist playlist;
typedef struct _playlistClass playlistClass;

#define TYPE_VIEWLIST (viewlist_get_type ())
#define VIEWLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIEWLIST, viewlist))
#define VIEWLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIEWLIST, viewlistClass))
#define IS_VIEWLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIEWLIST))
#define IS_VIEWLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIEWLIST))
#define VIEWLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIEWLIST, viewlistClass))

typedef struct _viewlist viewlist;
typedef struct _viewlistClass viewlistClass;

#define TYPE_EXTERNAL (external_get_type ())
#define EXTERNAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EXTERNAL, external))
#define EXTERNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EXTERNAL, externalClass))
#define IS_EXTERNAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EXTERNAL))
#define IS_EXTERNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EXTERNAL))
#define EXTERNAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EXTERNAL, externalClass))

typedef struct _external external;
typedef struct _externalClass externalClass;

#define TYPE_DBG (dbg_get_type ())
#define DBG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DBG, dbg))
#define DBG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DBG, dbgClass))
#define IS_DBG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DBG))
#define IS_DBG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DBG))
#define DBG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DBG, dbgClass))

typedef struct _dbg dbg;
typedef struct _dbgClass dbgClass;

#define TYPE_HELP (help_get_type ())
#define HELP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HELP, help))
#define HELP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HELP, helpClass))
#define IS_HELP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HELP))
#define IS_HELP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HELP))
#define HELP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HELP, helpClass))

typedef struct _help help;
typedef struct _helpClass helpClass;

#define TYPE_FILES (files_get_type ())
#define FILES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FILES, files))
#define FILES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FILES, filesClass))
#define IS_FILES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FILES))
#define IS_FILES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FILES))
#define FILES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FILES, filesClass))

typedef struct _files files;
typedef struct _filesClass filesClass;

#define TYPE_METHOD (method_get_type ())
#define METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METHOD, method))
#define METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METHOD, methodClass))
#define IS_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METHOD))
#define IS_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METHOD))
#define METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METHOD, methodClass))

typedef struct _method method;
typedef struct _methodClass methodClass;

#define WORLD_WIDE_TYPE_SCREEN_TYPE (world_wide_screen_type_get_type ())

#define WORLD_WIDE_TYPE_PLAYING_TYPE (world_wide_playing_type_get_type ())
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _screenPrivate screenPrivate;
#define _gst_mini_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_mini_object_unref (var), NULL)))

#define TYPE_FILE_TYPE (file_type_get_type ())
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
typedef struct _ParamSpecauditive ParamSpecauditive;
#define _auditive_unref0(var) ((var == NULL) ? NULL : (var = (auditive_unref (var), NULL)))

typedef void (*foreach_delegate) (GstTagList* list, const gchar* tag, void* user_data);
struct _auditive {
	GTypeInstance parent_instance;
	volatile int ref_count;
	auditivePrivate * priv;
	world_wide* world;
};

struct _auditiveClass {
	GTypeClass parent_class;
	void (*finalize) (auditive *self);
};

struct _auditivePrivate {
	GMainLoop* loop;
	GstElement* play;
	GstBus* bus;
	gint64 resume_position;
	gchar* song_label;
	gchar* song_title;
	gchar* song_artist;
	gchar* song_album;
	gchar* song_short_file_name;
	gint screen_size;
	gint auto_start_number;
	gchar* auto_start_name;
};

typedef enum  {
	WORLD_WIDE_SCREEN_TYPE_none,
	WORLD_WIDE_SCREEN_TYPE_file_list,
	WORLD_WIDE_SCREEN_TYPE_view_list,
	WORLD_WIDE_SCREEN_TYPE_play_list,
	WORLD_WIDE_SCREEN_TYPE_ext_list,
	WORLD_WIDE_SCREEN_TYPE_debug,
	WORLD_WIDE_SCREEN_TYPE_help
} world_widescreen_type;

typedef enum  {
	WORLD_WIDE_PLAYING_TYPE_stop,
	WORLD_WIDE_PLAYING_TYPE_play,
	WORLD_WIDE_PLAYING_TYPE_pause
} world_wideplaying_type;

struct _world_wide {
	GTypeInstance parent_instance;
	volatile int ref_count;
	world_widePrivate * priv;
	console* con;
	auditive* player;
	playlist* play_screen;
	viewlist* view_screen;
	external* ext_screen;
	dbg* debug;
	help* help_screen;
	GList* files_array;
	GList* keys_array;
	world_widescreen_type screen_current;
	world_wideplaying_type playing_state;
	gint screen_files;
	gboolean play_advance;
	screen* playing_screen;
	gint playlist_position;
};

struct _world_wideClass {
	GTypeClass parent_class;
	void (*finalize) (world_wide *self);
};

struct _screen {
	GTypeInstance parent_instance;
	volatile int ref_count;
	screenPrivate * priv;
	world_wide* world;
	gint screen_pos;
	gint row_pos;
	world_widescreen_type last_screen;
	gint key_handled;
};

struct _screenClass {
	GTypeClass parent_class;
	void (*finalize) (screen *self);
	gboolean (*has_title) (screen* self);
	gchar* (*get_title) (screen* self);
	void (*advance_song) (screen* self);
	gint (*get_size) (screen* self);
	gchar* (*calc_target) (screen* self, guint num);
	gchar* (*get_line) (screen* self, guint num);
	world_widescreen_type (*get_screen_type) (screen* self);
	void (*reset_stop) (screen* self);
	void (*draw) (screen* self);
	void (*key_press) (screen* self, gint key_num);
};

typedef enum  {
	FILE_TYPE_dir,
	FILE_TYPE_file,
	FILE_TYPE_m3u,
	FILE_TYPE_not_exist
} file_type;

struct _ParamSpecauditive {
	GParamSpec parent_instance;
};


static gpointer auditive_parent_class = NULL;

gboolean check_tag_exists (void* list, gchar* tag);
#define nsec ((gint64) 1000000000)
gchar* time_text (gint64 num);
gpointer auditive_ref (gpointer instance);
void auditive_unref (gpointer instance);
GParamSpec* param_spec_auditive (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_auditive (GValue* value, gpointer v_object);
void value_take_auditive (GValue* value, gpointer v_object);
gpointer value_get_auditive (const GValue* value);
GType auditive_get_type (void) G_GNUC_CONST;
gpointer world_wide_ref (gpointer instance);
void world_wide_unref (gpointer instance);
GParamSpec* param_spec_world_wide (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_world_wide (GValue* value, gpointer v_object);
void value_take_world_wide (GValue* value, gpointer v_object);
gpointer value_get_world_wide (const GValue* value);
GType world_wide_get_type (void) G_GNUC_CONST;
#define AUDITIVE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_AUDITIVE, auditivePrivate))
enum  {
	AUDITIVE_DUMMY_PROPERTY
};
auditive* auditive_new (void);
auditive* auditive_construct (GType object_type);
world_wide* world_wide_new (void);
world_wide* world_wide_construct (GType object_type);
gpointer console_ref (gpointer instance);
void console_unref (gpointer instance);
GParamSpec* param_spec_console (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_console (GValue* value, gpointer v_object);
void value_take_console (GValue* value, gpointer v_object);
gpointer value_get_console (const GValue* value);
GType console_get_type (void) G_GNUC_CONST;
gpointer screen_ref (gpointer instance);
void screen_unref (gpointer instance);
GParamSpec* param_spec_screen (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_screen (GValue* value, gpointer v_object);
void value_take_screen (GValue* value, gpointer v_object);
gpointer value_get_screen (const GValue* value);
GType screen_get_type (void) G_GNUC_CONST;
GType playlist_get_type (void) G_GNUC_CONST;
GType viewlist_get_type (void) G_GNUC_CONST;
GType external_get_type (void) G_GNUC_CONST;
GType dbg_get_type (void) G_GNUC_CONST;
GType help_get_type (void) G_GNUC_CONST;
GType files_get_type (void) G_GNUC_CONST;
gpointer method_ref (gpointer instance);
void method_unref (gpointer instance);
GParamSpec* param_spec_method (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_method (GValue* value, gpointer v_object);
void value_take_method (GValue* value, gpointer v_object);
gpointer value_get_method (const GValue* value);
GType method_get_type (void) G_GNUC_CONST;
GType world_wide_screen_type_get_type (void) G_GNUC_CONST;
GType world_wide_playing_type_get_type (void) G_GNUC_CONST;
dbg* dbg_new (world_wide* w);
dbg* dbg_construct (GType object_type, world_wide* w);
external* external_new (world_wide* w);
external* external_construct (GType object_type, world_wide* w);
help* help_new (world_wide* w);
help* help_construct (GType object_type, world_wide* w);
void config_setup (world_wide* world);
void auditive_set_playing (auditive* self, const gchar* source);
void auditive_stop (auditive* self);
gchar* get_file_from_path (const gchar* full_path);
static void auditive_element_make (auditive* self);
static inline void _dynamic_set_uri0 (GstElement* obj, gchar* value);
static gboolean auditive_bus_callback (auditive* self, GstBus* bus, GstMessage* message);
static gboolean _auditive_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
void auditive_playing (auditive* self);
void dbg_add (dbg* self, const gchar* text);
gchar* get_base_from_path (const gchar* full_path);
void screen_reset_stop (screen* self);
void auditive_advance_song (auditive* self);
void screen_advance_song (screen* self);
void auditive_draw (auditive* self);
gint64 auditive_get_position (auditive* self);
gint64 auditive_get_duration (auditive* self);
void auditive_set_position (auditive* self, gint64 position);
void auditive_pause (auditive* self);
void auditive_adjust_position (auditive* self, gint signed_seconds);
void auditive_adjust_position_fraction (auditive* self, gint signed_decivar);
screen* auditive_index_screen (auditive* self, world_widescreen_type screen_type);
void dbg_alert (dbg* self, const gchar* text);
void auditive_remember_screen (auditive* self, world_widescreen_type screen_type);
void screen_zoom_to_last_line (screen* self);
void auditive_restore_screen (auditive* self, world_widescreen_type screen_type);
static gboolean auditive_rememberable_screen (auditive* self, gint key_num, gint hot_key, world_widescreen_type screen_type);
#define CONSOLE_key_f1 265
#define CONSOLE_key_k1 ((gint) '1')
void console_cls (console* self);
static gboolean auditive_key_callback (auditive* self, GIOChannel* src, GIOCondition cond);
gint console_get_key (console* self);
#define CONSOLE_key_backspace ((gint) KEY_BACKSPACE)
void screen_key_press (screen* self, gint key_num);
void screen_draw (screen* self);
void auditive_draw_counter (auditive* self);
gboolean screen_has_title (screen* self);
void console_print_status (console* self, const gchar* text);
static gboolean auditive_tick_callback (auditive* self);
void files_play_a_song (files* self, const gchar* name);
void playlist_play_a_song (playlist* self, gint num);
gint console_calculate_screen_size (console* self);
void auditive_tag_reciever (auditive* self, GstTagList* list, const gchar* tag);
void console_refresh (console* self);
static void _auditive_tag_reciever_gst_tag_foreach_func (GstTagList* list, const gchar* tag, gpointer self);
void auditive_open_path (auditive* self, const gchar* path);
GType file_type_get_type (void) G_GNUC_CONST;
file_type determine_node (const gchar* path);
void start_from_new_path (world_wide* world, const gchar* full_path, gboolean do_draw, const gchar* zoom_into);
playlist* playlist_new_play_start (world_wide* w, const gchar* full_path);
playlist* playlist_construct_play_start (GType object_type, world_wide* w, const gchar* full_path);
void auditive_begin (auditive* self, const gchar* path);
static gboolean _auditive_tick_callback_gsource_func (gpointer self);
static gboolean _auditive_key_callback_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
void console_end (console* self);
static void auditive_finalize (auditive* obj);
gint _vala_main (gchar** args, int args_length1);
gchar* remove_slashes (const gchar* path);


gchar* time_text (gint64 num) {
	gchar* result = NULL;
	gint64 _tmp0_;
	gint64 total;
	gchar* _tmp1_ = NULL;
	_tmp0_ = num;
	total = _tmp0_ / nsec;
	_tmp1_ = g_strdup_printf ("%d:%02d", ((gint) total) / 60, ((gint) total) % 60);
	result = _tmp1_;
	return result;
}


auditive* auditive_construct (GType object_type) {
	auditive* self = NULL;
	world_wide* _tmp0_;
	world_wide* _tmp1_;
	world_wide* _tmp2_;
	world_wide* _tmp3_;
	dbg* _tmp4_;
	world_wide* _tmp5_;
	world_wide* _tmp6_;
	external* _tmp7_;
	world_wide* _tmp8_;
	world_wide* _tmp9_;
	help* _tmp10_;
	world_wide* _tmp11_;
	world_wide* _tmp12_;
	world_wide* _tmp13_;
	self = (auditive*) g_type_create_instance (object_type);
	_tmp0_ = world_wide_new ();
	self->world = _tmp0_;
	_tmp1_ = self->world;
	_tmp1_->player = self;
	_tmp2_ = self->world;
	_tmp3_ = self->world;
	_tmp4_ = dbg_new (_tmp3_);
	_tmp2_->debug = _tmp4_;
	_tmp5_ = self->world;
	_tmp6_ = self->world;
	_tmp7_ = external_new (_tmp6_);
	_tmp5_->ext_screen = _tmp7_;
	_tmp8_ = self->world;
	_tmp9_ = self->world;
	_tmp10_ = help_new (_tmp9_);
	_tmp8_->help_screen = _tmp10_;
	_tmp11_ = self->world;
	_tmp11_->playing_state = WORLD_WIDE_PLAYING_TYPE_stop;
	_tmp12_ = self->world;
	_g_list_free0 (_tmp12_->files_array);
	_tmp12_->files_array = NULL;
	_tmp13_ = self->world;
	config_setup (_tmp13_);
	return self;
}


auditive* auditive_new (void) {
	return auditive_construct (TYPE_AUDITIVE);
}


static inline void _dynamic_set_uri0 (GstElement* obj, gchar* value) {
	g_object_set (obj, "uri", value, NULL);
}


static gboolean _auditive_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
	gboolean result;
	result = auditive_bus_callback (self, bus, message);
	return result;
}


void auditive_set_playing (auditive* self, const gchar* source) {
	gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	GstElement* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GstElement* _tmp7_;
	GstBus* _tmp8_ = NULL;
	GstBus* _tmp9_;
	world_wide* _tmp10_;
	dbg* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	world_wide* _tmp15_;
	dbg* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	auditive_stop (self);
	_tmp0_ = g_strdup ("");
	_g_free0 (self->priv->song_label);
	self->priv->song_label = _tmp0_;
	_tmp1_ = source;
	_tmp2_ = get_file_from_path (_tmp1_);
	_g_free0 (self->priv->song_short_file_name);
	self->priv->song_short_file_name = _tmp2_;
	auditive_element_make (self);
	_tmp3_ = self->priv->play;
	_tmp4_ = source;
	_tmp5_ = g_strconcat ("file://", _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	_dynamic_set_uri0 (_tmp3_, _tmp6_);
	_g_free0 (_tmp6_);
	_tmp7_ = self->priv->play;
	_tmp8_ = gst_element_get_bus (_tmp7_);
	_g_object_unref0 (self->priv->bus);
	self->priv->bus = _tmp8_;
	_tmp9_ = self->priv->bus;
	gst_bus_add_watch_full (_tmp9_, G_PRIORITY_DEFAULT, _auditive_bus_callback_gst_bus_func, auditive_ref (self), auditive_unref);
	auditive_playing (self);
	_tmp10_ = self->world;
	_tmp11_ = _tmp10_->debug;
	_tmp12_ = self->priv->song_short_file_name;
	_tmp13_ = g_strconcat ("play ", _tmp12_, NULL);
	_tmp14_ = _tmp13_;
	dbg_add (_tmp11_, _tmp14_);
	_g_free0 (_tmp14_);
	_tmp15_ = self->world;
	_tmp16_ = _tmp15_->debug;
	_tmp17_ = source;
	_tmp18_ = get_base_from_path (_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strconcat ("from ", _tmp19_, NULL);
	_tmp21_ = _tmp20_;
	dbg_add (_tmp16_, _tmp21_);
	_g_free0 (_tmp21_);
	_g_free0 (_tmp19_);
}


void auditive_stop (auditive* self) {
	world_wide* _tmp0_;
	screen* _tmp1_;
	GstElement* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	world_wide* _tmp12_;
	world_wideplaying_type _tmp13_;
	world_wide* _tmp16_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->world;
	_tmp1_ = _tmp0_->playing_screen;
	if (_tmp1_ != NULL) {
		world_wide* _tmp2_;
		screen* _tmp3_;
		_tmp2_ = self->world;
		_tmp3_ = _tmp2_->playing_screen;
		screen_reset_stop (_tmp3_);
	}
	_tmp4_ = self->priv->play;
	gst_element_set_state (_tmp4_, GST_STATE_NULL);
	_tmp5_ = g_strdup ("");
	_g_free0 (self->priv->song_album);
	self->priv->song_album = _tmp5_;
	_tmp6_ = self->priv->song_album;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (self->priv->song_artist);
	self->priv->song_artist = _tmp7_;
	_tmp8_ = self->priv->song_artist;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 (self->priv->song_title);
	self->priv->song_title = _tmp9_;
	_tmp10_ = self->priv->song_title;
	_tmp11_ = g_strdup (_tmp10_);
	_g_free0 (self->priv->song_label);
	self->priv->song_label = _tmp11_;
	_tmp12_ = self->world;
	_tmp13_ = _tmp12_->playing_state;
	if (_tmp13_ != WORLD_WIDE_PLAYING_TYPE_stop) {
		world_wide* _tmp14_;
		dbg* _tmp15_;
		_tmp14_ = self->world;
		_tmp15_ = _tmp14_->debug;
		dbg_add (_tmp15_, "stop");
	}
	_tmp16_ = self->world;
	_tmp16_->playing_state = WORLD_WIDE_PLAYING_TYPE_stop;
}


void auditive_advance_song (auditive* self) {
	world_wide* _tmp0_;
	screen* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->world;
	_tmp1_ = _tmp0_->playing_screen;
	if (_tmp1_ == NULL) {
		auditive_stop (self);
	} else {
		world_wide* _tmp2_;
		screen* _tmp3_;
		_tmp2_ = self->world;
		_tmp3_ = _tmp2_->playing_screen;
		screen_advance_song (_tmp3_);
	}
	auditive_draw (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void auditive_element_make (auditive* self) {
	GstElement* _tmp0_ = NULL;
	GstElement* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gst_element_factory_make ("playbin", "play");
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->play);
	self->priv->play = _tmp1_;
}


gint64 auditive_get_position (auditive* self) {
	gint64 result = 0LL;
	gint64 position = 0LL;
	GstFormat fmt;
	GstElement* _tmp0_;
	gint64 _tmp1_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	fmt = GST_FORMAT_TIME;
	_tmp0_ = self->priv->play;
	gst_element_query_position (_tmp0_, fmt, &_tmp1_);
	position = _tmp1_;
	result = position;
	return result;
}


gint64 auditive_get_duration (auditive* self) {
	gint64 result = 0LL;
	gint64 duration = 0LL;
	GstFormat fmt;
	GstElement* _tmp0_;
	gint64 _tmp1_ = 0LL;
	g_return_val_if_fail (self != NULL, 0LL);
	fmt = GST_FORMAT_TIME;
	_tmp0_ = self->priv->play;
	gst_element_query_duration (_tmp0_, fmt, &_tmp1_);
	duration = _tmp1_;
	result = duration;
	return result;
}


void auditive_set_position (auditive* self, gint64 position) {
	GstElement* _tmp0_;
	gint64 _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->play;
	_tmp1_ = position;
	gst_element_seek_simple (_tmp0_, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, _tmp1_);
}


void auditive_pause (auditive* self) {
	GstElement* _tmp0_;
	world_wide* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->play;
	gst_element_set_state (_tmp0_, GST_STATE_PAUSED);
	_tmp1_ = self->world;
	_tmp1_->playing_state = WORLD_WIDE_PLAYING_TYPE_pause;
}


void auditive_playing (auditive* self) {
	GstElement* _tmp0_;
	world_wide* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->play;
	gst_element_set_state (_tmp0_, GST_STATE_PLAYING);
	_tmp1_ = self->world;
	_tmp1_->playing_state = WORLD_WIDE_PLAYING_TYPE_play;
}


void auditive_adjust_position (auditive* self, gint signed_seconds) {
	gint64 _tmp0_ = 0LL;
	gint _tmp1_;
	gint64 new_position;
	gboolean _tmp2_ = FALSE;
	gint64 _tmp3_;
	gboolean _tmp6_;
	gint64 _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = auditive_get_position (self);
	_tmp1_ = signed_seconds;
	new_position = _tmp0_ + (_tmp1_ * nsec);
	_tmp3_ = new_position;
	if (_tmp3_ < ((gint64) 0)) {
		_tmp2_ = TRUE;
	} else {
		gint64 _tmp4_;
		gint64 _tmp5_ = 0LL;
		_tmp4_ = new_position;
		_tmp5_ = auditive_get_duration (self);
		_tmp2_ = _tmp4_ >= _tmp5_;
	}
	_tmp6_ = _tmp2_;
	if (_tmp6_) {
		return;
	}
	_tmp7_ = new_position;
	auditive_set_position (self, _tmp7_);
}


void auditive_adjust_position_fraction (auditive* self, gint signed_decivar) {
	gint64 _tmp0_ = 0LL;
	gint64 adjust;
	gint64 _tmp1_;
	gint64 _tmp2_;
	gint _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = auditive_get_duration (self);
	adjust = _tmp0_ / (nsec * 10);
	_tmp1_ = adjust;
	if (_tmp1_ > ((gint64) 123000456)) {
		return;
	}
	_tmp2_ = adjust;
	_tmp3_ = signed_decivar;
	auditive_adjust_position (self, ((gint) _tmp2_) * _tmp3_);
}


screen* auditive_index_screen (auditive* self, world_widescreen_type screen_type) {
	screen* result = NULL;
	world_widescreen_type _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = screen_type;
	switch (_tmp0_) {
		case WORLD_WIDE_SCREEN_TYPE_file_list:
		{
			world_wide* _tmp1_;
			GList* _tmp2_;
			world_wide* _tmp3_;
			gint _tmp4_;
			gconstpointer _tmp5_ = NULL;
			_tmp1_ = self->world;
			_tmp2_ = _tmp1_->files_array;
			_tmp3_ = self->world;
			_tmp4_ = _tmp3_->screen_files;
			_tmp5_ = g_list_nth_data (_tmp2_, (guint) _tmp4_);
			result = (screen*) _tmp5_;
			return result;
		}
		case WORLD_WIDE_SCREEN_TYPE_view_list:
		{
			world_wide* _tmp6_;
			viewlist* _tmp7_;
			_tmp6_ = self->world;
			_tmp7_ = _tmp6_->view_screen;
			result = (screen*) _tmp7_;
			return result;
		}
		case WORLD_WIDE_SCREEN_TYPE_play_list:
		{
			world_wide* _tmp8_;
			playlist* _tmp9_;
			_tmp8_ = self->world;
			_tmp9_ = _tmp8_->play_screen;
			result = (screen*) _tmp9_;
			return result;
		}
		case WORLD_WIDE_SCREEN_TYPE_ext_list:
		{
			world_wide* _tmp10_;
			external* _tmp11_;
			_tmp10_ = self->world;
			_tmp11_ = _tmp10_->ext_screen;
			result = (screen*) _tmp11_;
			return result;
		}
		case WORLD_WIDE_SCREEN_TYPE_debug:
		{
			world_wide* _tmp12_;
			dbg* _tmp13_;
			_tmp12_ = self->world;
			_tmp13_ = _tmp12_->debug;
			result = (screen*) _tmp13_;
			return result;
		}
		case WORLD_WIDE_SCREEN_TYPE_help:
		{
			world_wide* _tmp14_;
			help* _tmp15_;
			_tmp14_ = self->world;
			_tmp15_ = _tmp14_->help_screen;
			result = (screen*) _tmp15_;
			return result;
		}
		default:
		{
			world_wide* _tmp16_;
			dbg* _tmp17_;
			world_wide* _tmp18_;
			dbg* _tmp19_;
			_tmp16_ = self->world;
			_tmp17_ = _tmp16_->debug;
			dbg_alert (_tmp17_, "Undetermined screen");
			_tmp18_ = self->world;
			_tmp19_ = _tmp18_->debug;
			result = (screen*) _tmp19_;
			return result;
		}
	}
}


void auditive_remember_screen (auditive* self, world_widescreen_type screen_type) {
	world_widescreen_type _tmp0_;
	screen* _tmp1_ = NULL;
	world_wide* _tmp2_;
	world_widescreen_type _tmp3_;
	world_wide* _tmp4_;
	world_widescreen_type _tmp5_;
	world_widescreen_type _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = screen_type;
	_tmp1_ = auditive_index_screen (self, _tmp0_);
	_tmp2_ = self->world;
	_tmp3_ = _tmp2_->screen_current;
	_tmp1_->last_screen = _tmp3_;
	_tmp4_ = self->world;
	_tmp5_ = screen_type;
	_tmp4_->screen_current = _tmp5_;
	_tmp6_ = screen_type;
	if (_tmp6_ == WORLD_WIDE_SCREEN_TYPE_debug) {
		world_wide* _tmp7_;
		dbg* _tmp8_;
		_tmp7_ = self->world;
		_tmp8_ = _tmp7_->debug;
		screen_zoom_to_last_line ((screen*) _tmp8_);
	}
	auditive_draw (self);
}


void auditive_restore_screen (auditive* self, world_widescreen_type screen_type) {
	world_wide* _tmp0_;
	world_wide* _tmp1_;
	world_widescreen_type _tmp2_;
	screen* _tmp3_ = NULL;
	world_widescreen_type _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->world;
	_tmp1_ = self->world;
	_tmp2_ = _tmp1_->screen_current;
	_tmp3_ = auditive_index_screen (self, _tmp2_);
	_tmp4_ = _tmp3_->last_screen;
	_tmp0_->screen_current = _tmp4_;
	auditive_draw (self);
}


static gboolean auditive_rememberable_screen (auditive* self, gint key_num, gint hot_key, world_widescreen_type screen_type) {
	gboolean result = FALSE;
	gboolean hit;
	gint f1;
	gint k1;
	gint _tmp0_;
	gboolean _tmp9_;
	world_widescreen_type _tmp10_;
	screen* _tmp11_ = NULL;
	world_wide* _tmp12_;
	console* _tmp13_;
	gboolean _tmp14_ = FALSE;
	world_wide* _tmp15_;
	world_widescreen_type _tmp16_;
	world_widescreen_type _tmp17_;
	gboolean _tmp21_;
	g_return_val_if_fail (self != NULL, FALSE);
	hit = FALSE;
	f1 = CONSOLE_key_f1;
	k1 = CONSOLE_key_k1;
	_tmp0_ = hot_key;
	if (_tmp0_ > 12) {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = key_num;
		_tmp2_ = hot_key;
		if (_tmp1_ == _tmp2_) {
			hit = TRUE;
		}
	} else {
		gint _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp3_ = key_num;
		_tmp4_ = f1;
		_tmp5_ = hot_key;
		if (_tmp3_ == ((_tmp4_ + _tmp5_) - 1)) {
			hit = TRUE;
		}
		_tmp6_ = key_num;
		_tmp7_ = k1;
		_tmp8_ = hot_key;
		if (_tmp6_ == ((_tmp7_ + _tmp8_) - 1)) {
			hit = TRUE;
		}
	}
	_tmp9_ = hit;
	if (!_tmp9_) {
		result = FALSE;
		return result;
	}
	_tmp10_ = screen_type;
	_tmp11_ = auditive_index_screen (self, _tmp10_);
	if (_tmp11_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp12_ = self->world;
	_tmp13_ = _tmp12_->con;
	console_cls (_tmp13_);
	_tmp15_ = self->world;
	_tmp16_ = _tmp15_->screen_current;
	_tmp17_ = screen_type;
	if (_tmp16_ == _tmp17_) {
		world_widescreen_type _tmp18_;
		screen* _tmp19_ = NULL;
		world_widescreen_type _tmp20_;
		_tmp18_ = screen_type;
		_tmp19_ = auditive_index_screen (self, _tmp18_);
		_tmp20_ = _tmp19_->last_screen;
		_tmp14_ = _tmp20_ != WORLD_WIDE_SCREEN_TYPE_none;
	} else {
		_tmp14_ = FALSE;
	}
	_tmp21_ = _tmp14_;
	if (_tmp21_) {
		world_widescreen_type _tmp22_;
		_tmp22_ = screen_type;
		auditive_restore_screen (self, _tmp22_);
	} else {
		world_widescreen_type _tmp23_;
		_tmp23_ = screen_type;
		auditive_remember_screen (self, _tmp23_);
	}
	result = TRUE;
	return result;
}


static gboolean auditive_key_callback (auditive* self, GIOChannel* src, GIOCondition cond) {
	gboolean result = FALSE;
	world_wide* _tmp0_;
	console* _tmp1_;
	gint _tmp2_ = 0;
	gint key_num;
	gint _tmp3_;
	gboolean _tmp4_ = FALSE;
	gint _tmp5_;
	gboolean _tmp6_ = FALSE;
	gint _tmp7_;
	gboolean _tmp8_ = FALSE;
	gint _tmp9_;
	gboolean _tmp10_ = FALSE;
	gint _tmp11_;
	gboolean _tmp12_ = FALSE;
	gint _tmp13_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (src != NULL, FALSE);
	_tmp0_ = self->world;
	_tmp1_ = _tmp0_->con;
	_tmp2_ = console_get_key (_tmp1_);
	key_num = _tmp2_;
	_tmp3_ = key_num;
	_tmp4_ = auditive_rememberable_screen (self, _tmp3_, 1, WORLD_WIDE_SCREEN_TYPE_help);
	if (_tmp4_) {
		key_num = 0;
	}
	_tmp5_ = key_num;
	_tmp6_ = auditive_rememberable_screen (self, _tmp5_, 2, WORLD_WIDE_SCREEN_TYPE_file_list);
	if (_tmp6_) {
		key_num = 0;
	}
	_tmp7_ = key_num;
	_tmp8_ = auditive_rememberable_screen (self, _tmp7_, 3, WORLD_WIDE_SCREEN_TYPE_play_list);
	if (_tmp8_) {
		key_num = 0;
	}
	_tmp9_ = key_num;
	_tmp10_ = auditive_rememberable_screen (self, _tmp9_, 4, WORLD_WIDE_SCREEN_TYPE_ext_list);
	if (_tmp10_) {
		key_num = 0;
	}
	_tmp11_ = key_num;
	_tmp12_ = auditive_rememberable_screen (self, _tmp11_, (gint) '`', WORLD_WIDE_SCREEN_TYPE_debug);
	if (_tmp12_) {
		key_num = 0;
	}
	_tmp13_ = key_num;
	switch (_tmp13_) {
		case 0:
		{
			break;
		}
		case 'q':
		{
			GMainLoop* _tmp14_;
			_tmp14_ = self->priv->loop;
			g_main_loop_quit (_tmp14_);
			break;
		}
		case CONSOLE_key_backspace:
		{
			world_wide* _tmp15_;
			auditive_stop (self);
			_tmp15_ = self->world;
			_tmp15_->playlist_position = -1;
			auditive_draw (self);
			break;
		}
		case ' ':
		{
			world_wide* _tmp16_;
			world_wideplaying_type _tmp17_;
			_tmp16_ = self->world;
			_tmp17_ = _tmp16_->playing_state;
			switch (_tmp17_) {
				case WORLD_WIDE_PLAYING_TYPE_play:
				{
					gint64 _tmp18_ = 0LL;
					_tmp18_ = auditive_get_position (self);
					self->priv->resume_position = _tmp18_;
					auditive_pause (self);
					break;
				}
				case WORLD_WIDE_PLAYING_TYPE_pause:
				{
					GstElement* _tmp19_;
					gint64 _tmp20_;
					_tmp19_ = self->priv->play;
					_tmp20_ = self->priv->resume_position;
					gst_element_seek_simple (_tmp19_, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, _tmp20_);
					auditive_playing (self);
					break;
				}
				default:
				break;
			}
			break;
		}
		case '\\':
		{
			auditive_advance_song (self);
			break;
		}
		case ',':
		{
			auditive_adjust_position (self, -5);
			break;
		}
		case '.':
		{
			auditive_adjust_position (self, +5);
			break;
		}
		case '[':
		{
			auditive_adjust_position (self, -60);
			break;
		}
		case ']':
		{
			auditive_adjust_position (self, +60);
			break;
		}
		case '{':
		{
			auditive_adjust_position_fraction (self, -1);
			break;
		}
		case '}':
		{
			auditive_adjust_position_fraction (self, +1);
			break;
		}
		case '-':
		{
			world_wide* _tmp21_;
			world_wide* _tmp22_;
			gboolean _tmp23_;
			_tmp21_ = self->world;
			_tmp22_ = self->world;
			_tmp23_ = _tmp22_->play_advance;
			_tmp21_->play_advance = !_tmp23_;
			auditive_draw (self);
			break;
		}
		default:
		{
			world_wide* _tmp24_;
			world_widescreen_type _tmp25_;
			screen* _tmp26_ = NULL;
			gint _tmp27_;
			_tmp24_ = self->world;
			_tmp25_ = _tmp24_->screen_current;
			_tmp26_ = auditive_index_screen (self, _tmp25_);
			_tmp27_ = key_num;
			screen_key_press (_tmp26_, _tmp27_);
			break;
		}
	}
	result = TRUE;
	return result;
}


void auditive_draw (auditive* self) {
	world_wide* _tmp0_;
	world_widescreen_type _tmp1_;
	screen* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->world;
	_tmp1_ = _tmp0_->screen_current;
	_tmp2_ = auditive_index_screen (self, _tmp1_);
	screen_draw (_tmp2_);
	auditive_draw_counter (self);
}


void auditive_draw_counter (auditive* self) {
	world_wide* _tmp0_;
	world_widescreen_type _tmp1_;
	screen* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gchar* text = NULL;
	world_wide* _tmp4_;
	world_wideplaying_type _tmp5_;
	world_wide* _tmp33_;
	console* _tmp34_;
	const gchar* _tmp35_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->world;
	_tmp1_ = _tmp0_->screen_current;
	_tmp2_ = auditive_index_screen (self, _tmp1_);
	_tmp3_ = screen_has_title (_tmp2_);
	if (!_tmp3_) {
		return;
	}
	_tmp4_ = self->world;
	_tmp5_ = _tmp4_->playing_state;
	if (_tmp5_ == WORLD_WIDE_PLAYING_TYPE_stop) {
		gchar* _tmp6_;
		_tmp6_ = g_strdup ("  0:00");
		_g_free0 (text);
		text = _tmp6_;
	} else {
		gint64 _tmp7_ = 0LL;
		gint64 position;
		gint64 _tmp8_;
		gint64 _tmp9_;
		gint64 _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		gint64 _tmp17_ = 0LL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_;
		gchar* _tmp20_;
		const gchar* _tmp21_;
		_tmp7_ = auditive_get_position (self);
		position = _tmp7_;
		_tmp8_ = position;
		if (_tmp8_ == ((gint64) 0)) {
			_g_free0 (text);
			return;
		}
		_tmp9_ = position;
		self->priv->resume_position = _tmp9_;
		_tmp10_ = position;
		_tmp11_ = time_text (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_strconcat ("  ", _tmp12_, NULL);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_strconcat (_tmp14_, "/", NULL);
		_tmp16_ = _tmp15_;
		_tmp17_ = auditive_get_duration (self);
		_tmp18_ = time_text (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = g_strconcat (_tmp16_, _tmp19_, NULL);
		_g_free0 (text);
		text = _tmp20_;
		_g_free0 (_tmp19_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp14_);
		_g_free0 (_tmp12_);
		_tmp21_ = self->priv->song_label;
		if (g_strcmp0 (_tmp21_, "") != 0) {
			const gchar* _tmp22_;
			gchar* _tmp23_;
			gchar* _tmp24_;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			_tmp22_ = text;
			_tmp23_ = g_strconcat (_tmp22_, " ", NULL);
			_tmp24_ = _tmp23_;
			_tmp25_ = self->priv->song_label;
			_tmp26_ = g_strconcat (_tmp24_, _tmp25_, NULL);
			_g_free0 (text);
			text = _tmp26_;
			_g_free0 (_tmp24_);
		} else {
			gint64 _tmp27_;
			_tmp27_ = position;
			if (((_tmp27_ * 10) / nsec) > ((gint64) 2)) {
				const gchar* _tmp28_;
				gchar* _tmp29_;
				gchar* _tmp30_;
				const gchar* _tmp31_;
				gchar* _tmp32_;
				_tmp28_ = text;
				_tmp29_ = g_strconcat (_tmp28_, " ", NULL);
				_tmp30_ = _tmp29_;
				_tmp31_ = self->priv->song_short_file_name;
				_tmp32_ = g_strconcat (_tmp30_, _tmp31_, NULL);
				_g_free0 (text);
				text = _tmp32_;
				_g_free0 (_tmp30_);
			}
		}
	}
	_tmp33_ = self->world;
	_tmp34_ = _tmp33_->con;
	_tmp35_ = text;
	console_print_status (_tmp34_, _tmp35_);
	_g_free0 (text);
}


static gboolean auditive_tick_callback (auditive* self) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gint _tmp10_;
	world_wide* _tmp16_;
	console* _tmp17_;
	gint _tmp18_ = 0;
	gint new_screen_size;
	gint _tmp19_;
	gint _tmp20_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->auto_start_name;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		world_wide* _tmp1_;
		GList* _tmp2_;
		world_wide* _tmp3_;
		gint _tmp4_;
		gconstpointer _tmp5_ = NULL;
		files* a_file;
		files* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		files* _tmp9_;
		_tmp1_ = self->world;
		_tmp2_ = _tmp1_->files_array;
		_tmp3_ = self->world;
		_tmp4_ = _tmp3_->screen_files;
		_tmp5_ = g_list_nth_data (_tmp2_, (guint) _tmp4_);
		a_file = (files*) _tmp5_;
		_tmp6_ = a_file;
		_tmp7_ = self->priv->auto_start_name;
		files_play_a_song (_tmp6_, _tmp7_);
		_tmp8_ = g_strdup ("");
		_g_free0 (self->priv->auto_start_name);
		self->priv->auto_start_name = _tmp8_;
		_tmp9_ = a_file;
		screen_draw ((screen*) _tmp9_);
	}
	_tmp10_ = self->priv->auto_start_number;
	if (_tmp10_ >= 0) {
		world_wide* _tmp11_;
		playlist* _tmp12_;
		gint _tmp13_;
		world_wide* _tmp14_;
		playlist* _tmp15_;
		_tmp11_ = self->world;
		_tmp12_ = _tmp11_->play_screen;
		_tmp13_ = self->priv->auto_start_number;
		playlist_play_a_song (_tmp12_, _tmp13_);
		self->priv->auto_start_number = -1;
		_tmp14_ = self->world;
		_tmp15_ = _tmp14_->play_screen;
		screen_draw ((screen*) _tmp15_);
	}
	_tmp16_ = self->world;
	_tmp17_ = _tmp16_->con;
	_tmp18_ = console_calculate_screen_size (_tmp17_);
	new_screen_size = _tmp18_;
	_tmp19_ = new_screen_size;
	_tmp20_ = self->priv->screen_size;
	if (_tmp19_ != _tmp20_) {
		world_wide* _tmp21_;
		console* _tmp22_;
		gint _tmp23_;
		world_wide* _tmp24_;
		world_widescreen_type _tmp25_;
		screen* _tmp26_ = NULL;
		_tmp21_ = self->world;
		_tmp22_ = _tmp21_->con;
		console_cls (_tmp22_);
		_tmp23_ = new_screen_size;
		self->priv->screen_size = _tmp23_;
		_tmp24_ = self->world;
		_tmp25_ = _tmp24_->screen_current;
		_tmp26_ = auditive_index_screen (self, _tmp25_);
		screen_draw (_tmp26_);
	}
	auditive_draw_counter (self);
	result = TRUE;
	return result;
}


void auditive_tag_reciever (auditive* self, GstTagList* list, const gchar* tag) {
	gchar* field = NULL;
	gchar* data = NULL;
	GstTagList* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (list != NULL);
	g_return_if_fail (tag != NULL);
	_tmp0_ = list;
	_tmp1_ = tag;
	_tmp2_ = check_tag_exists ((void*) _tmp0_, (gchar*) _tmp1_);
	if (_tmp2_) {
		GstTagList* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		const gchar* _tmp8_;
		const gchar* _tmp11_;
		const gchar* _tmp14_;
		const gchar* _tmp17_;
		world_wide* _tmp26_;
		dbg* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_;
		gchar* _tmp30_;
		gchar* _tmp31_;
		gchar* _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		gchar* _tmp35_;
		_tmp3_ = list;
		_tmp4_ = tag;
		gst_tag_list_get_string (_tmp3_, _tmp4_, &_tmp5_);
		_g_free0 (data);
		data = _tmp5_;
		_tmp6_ = tag;
		_tmp7_ = g_utf8_strdown (_tmp6_, (gssize) (-1));
		_g_free0 (field);
		field = _tmp7_;
		_tmp8_ = field;
		if (g_strcmp0 (_tmp8_, "title") == 0) {
			const gchar* _tmp9_;
			gchar* _tmp10_;
			_tmp9_ = data;
			_tmp10_ = g_strdup (_tmp9_);
			_g_free0 (self->priv->song_title);
			self->priv->song_title = _tmp10_;
		}
		_tmp11_ = field;
		if (g_strcmp0 (_tmp11_, "artist") == 0) {
			const gchar* _tmp12_;
			gchar* _tmp13_;
			_tmp12_ = data;
			_tmp13_ = g_strdup (_tmp12_);
			_g_free0 (self->priv->song_artist);
			self->priv->song_artist = _tmp13_;
		}
		_tmp14_ = field;
		if (g_strcmp0 (_tmp14_, "album") == 0) {
			const gchar* _tmp15_;
			gchar* _tmp16_;
			_tmp15_ = data;
			_tmp16_ = g_strdup (_tmp15_);
			_g_free0 (self->priv->song_album);
			self->priv->song_album = _tmp16_;
		}
		_tmp17_ = self->priv->song_title;
		if (g_strcmp0 (_tmp17_, "") != 0) {
			const gchar* _tmp18_;
			_tmp18_ = self->priv->song_artist;
			if (g_strcmp0 (_tmp18_, "") != 0) {
				const gchar* _tmp19_;
				gchar* _tmp20_;
				gchar* _tmp21_;
				const gchar* _tmp22_;
				gchar* _tmp23_;
				_tmp19_ = self->priv->song_title;
				_tmp20_ = g_strconcat (_tmp19_, " - ", NULL);
				_tmp21_ = _tmp20_;
				_tmp22_ = self->priv->song_artist;
				_tmp23_ = g_strconcat (_tmp21_, _tmp22_, NULL);
				_g_free0 (self->priv->song_label);
				self->priv->song_label = _tmp23_;
				_g_free0 (_tmp21_);
			} else {
				const gchar* _tmp24_;
				gchar* _tmp25_;
				_tmp24_ = self->priv->song_title;
				_tmp25_ = g_strdup (_tmp24_);
				_g_free0 (self->priv->song_label);
				self->priv->song_label = _tmp25_;
			}
		}
		_tmp26_ = self->world;
		_tmp27_ = _tmp26_->debug;
		_tmp28_ = tag;
		_tmp29_ = g_strconcat ("tag: ", _tmp28_, NULL);
		_tmp30_ = _tmp29_;
		_tmp31_ = g_strconcat (_tmp30_, ": ", NULL);
		_tmp32_ = _tmp31_;
		_tmp33_ = data;
		_tmp34_ = g_strconcat (_tmp32_, _tmp33_, NULL);
		_tmp35_ = _tmp34_;
		dbg_add (_tmp27_, _tmp35_);
		_g_free0 (_tmp35_);
		_g_free0 (_tmp32_);
		_g_free0 (_tmp30_);
	} else {
		world_wide* _tmp36_;
		dbg* _tmp37_;
		const gchar* _tmp38_;
		gchar* _tmp39_;
		gchar* _tmp40_;
		_tmp36_ = self->world;
		_tmp37_ = _tmp36_->debug;
		_tmp38_ = tag;
		_tmp39_ = g_strconcat ("empty tag: ", _tmp38_, NULL);
		_tmp40_ = _tmp39_;
		dbg_add (_tmp37_, _tmp40_);
		_g_free0 (_tmp40_);
	}
	_g_free0 (data);
	_g_free0 (field);
}


static void _auditive_tag_reciever_gst_tag_foreach_func (GstTagList* list, const gchar* tag, gpointer self) {
	auditive_tag_reciever (self, list, tag);
}


static gboolean auditive_bus_callback (auditive* self, GstBus* bus, GstMessage* message) {
	gboolean result = FALSE;
	GstMessage* _tmp0_;
	GstMessageType _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	_tmp0_ = message;
	_tmp1_ = _tmp0_->type;
	switch (_tmp1_) {
		case GST_MESSAGE_EOS:
		{
			world_wide* _tmp2_;
			gboolean _tmp3_;
			_tmp2_ = self->world;
			_tmp3_ = _tmp2_->play_advance;
			if (_tmp3_ == FALSE) {
				auditive_stop (self);
				auditive_draw (self);
			} else {
				auditive_advance_song (self);
			}
			break;
		}
		case GST_MESSAGE_ERROR:
		case GST_MESSAGE_WARNING:
		case GST_MESSAGE_ELEMENT:
		{
			world_wide* _tmp4_;
			dbg* _tmp5_;
			GstMessage* _tmp6_;
			GstMessageType _tmp7_;
			gchar* _tmp8_ = NULL;
			gchar* _tmp9_;
			world_wide* _tmp10_;
			console* _tmp11_;
			world_wide* _tmp12_;
			console* _tmp13_;
			_tmp4_ = self->world;
			_tmp5_ = _tmp4_->debug;
			_tmp6_ = message;
			_tmp7_ = _tmp6_->type;
			_tmp8_ = g_strdup_printf ("Stop: %x", (guint) _tmp7_);
			_tmp9_ = _tmp8_;
			dbg_add (_tmp5_, _tmp9_);
			_g_free0 (_tmp9_);
			auditive_stop (self);
			_tmp10_ = self->world;
			_tmp11_ = _tmp10_->con;
			console_cls (_tmp11_);
			_tmp12_ = self->world;
			_tmp13_ = _tmp12_->con;
			console_refresh (_tmp13_);
			auditive_draw (self);
			break;
		}
		case GST_MESSAGE_TAG:
		{
			GstTagList* tag_list = NULL;
			GstMessage* _tmp14_;
			GstTagList* _tmp15_ = NULL;
			GstTagList* _tmp16_;
			_tmp14_ = message;
			gst_message_parse_tag (_tmp14_, &_tmp15_);
			_gst_mini_object_unref0 (tag_list);
			tag_list = _tmp15_;
			_tmp16_ = tag_list;
			gst_tag_list_foreach (_tmp16_, _auditive_tag_reciever_gst_tag_foreach_func, self);
			_gst_mini_object_unref0 (tag_list);
			break;
		}
		default:
		break;
	}
	result = TRUE;
	return result;
}


void auditive_open_path (auditive* self, const gchar* path) {
	const gchar* _tmp0_;
	file_type _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = determine_node (_tmp0_);
	switch (_tmp1_) {
		case FILE_TYPE_dir:
		{
			world_wide* _tmp2_;
			const gchar* _tmp3_;
			_tmp2_ = self->world;
			_tmp3_ = path;
			start_from_new_path (_tmp2_, _tmp3_, TRUE, "");
			break;
		}
		case FILE_TYPE_file:
		{
			const gchar* _tmp4_;
			gchar* _tmp5_ = NULL;
			world_wide* _tmp6_;
			const gchar* _tmp7_;
			gchar* _tmp8_ = NULL;
			gchar* _tmp9_;
			const gchar* _tmp10_;
			_tmp4_ = path;
			_tmp5_ = get_file_from_path (_tmp4_);
			_g_free0 (self->priv->auto_start_name);
			self->priv->auto_start_name = _tmp5_;
			_tmp6_ = self->world;
			_tmp7_ = path;
			_tmp8_ = get_base_from_path (_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp10_ = self->priv->auto_start_name;
			start_from_new_path (_tmp6_, _tmp9_, TRUE, _tmp10_);
			_g_free0 (_tmp9_);
			break;
		}
		case FILE_TYPE_m3u:
		{
			world_wide* _tmp11_;
			const gchar* _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			world_wide* _tmp15_;
			world_wide* _tmp16_;
			GList* _tmp17_;
			guint _tmp18_ = 0U;
			world_wide* _tmp19_;
			world_wide* _tmp20_;
			const gchar* _tmp21_;
			playlist* _tmp22_;
			_tmp11_ = self->world;
			_tmp12_ = path;
			_tmp13_ = get_base_from_path (_tmp12_);
			_tmp14_ = _tmp13_;
			start_from_new_path (_tmp11_, _tmp14_, FALSE, "");
			_g_free0 (_tmp14_);
			_tmp15_ = self->world;
			_tmp16_ = self->world;
			_tmp17_ = _tmp16_->files_array;
			_tmp18_ = g_list_length (_tmp17_);
			_tmp15_->screen_files = ((gint) _tmp18_) - 1;
			_tmp19_ = self->world;
			_tmp20_ = self->world;
			_tmp21_ = path;
			_tmp22_ = playlist_new_play_start (_tmp20_, _tmp21_);
			_tmp19_->play_screen = _tmp22_;
			self->priv->auto_start_number = 0;
			break;
		}
		case FILE_TYPE_not_exist:
		{
			world_wide* _tmp23_;
			dbg* _tmp24_;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			gchar* _tmp27_;
			_tmp23_ = self->world;
			_tmp24_ = _tmp23_->debug;
			_tmp25_ = path;
			_tmp26_ = g_strconcat ("bad path: ", _tmp25_, NULL);
			_tmp27_ = _tmp26_;
			dbg_add (_tmp24_, _tmp27_);
			_g_free0 (_tmp27_);
			break;
		}
		default:
		break;
	}
}


static gboolean _auditive_tick_callback_gsource_func (gpointer self) {
	gboolean result;
	result = auditive_tick_callback (self);
	return result;
}


static gboolean _auditive_key_callback_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = auditive_key_callback (self, source, condition);
	return result;
}


void auditive_begin (auditive* self, const gchar* path) {
	GIOChannel* _tmp0_;
	GIOChannel* ioc;
	const gchar* _tmp1_;
	GMainLoop* _tmp2_;
	world_wide* _tmp3_;
	console* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 250, _auditive_tick_callback_gsource_func, auditive_ref (self), auditive_unref);
	_tmp0_ = g_io_channel_unix_new (0);
	ioc = _tmp0_;
	g_io_add_watch (ioc, G_IO_IN, _auditive_key_callback_gio_func, self);
	_tmp1_ = path;
	auditive_open_path (self, _tmp1_);
	auditive_element_make (self);
	_tmp2_ = self->priv->loop;
	g_main_loop_run (_tmp2_);
	_tmp3_ = self->world;
	_tmp4_ = _tmp3_->con;
	console_end (_tmp4_);
	_g_io_channel_unref0 (ioc);
}


static void value_auditive_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_auditive_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		auditive_unref (value->data[0].v_pointer);
	}
}


static void value_auditive_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = auditive_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_auditive_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_auditive_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		auditive* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = auditive_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_auditive_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	auditive** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = auditive_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_auditive (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecauditive* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_AUDITIVE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_auditive (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_AUDITIVE), NULL);
	return value->data[0].v_pointer;
}


void value_set_auditive (GValue* value, gpointer v_object) {
	auditive* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_AUDITIVE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_AUDITIVE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		auditive_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		auditive_unref (old);
	}
}


void value_take_auditive (GValue* value, gpointer v_object) {
	auditive* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_AUDITIVE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_AUDITIVE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		auditive_unref (old);
	}
}


static void auditive_class_init (auditiveClass * klass) {
	auditive_parent_class = g_type_class_peek_parent (klass);
	AUDITIVE_CLASS (klass)->finalize = auditive_finalize;
	g_type_class_add_private (klass, sizeof (auditivePrivate));
}


static void auditive_instance_init (auditive * self) {
	GMainLoop* _tmp0_;
	gchar* _tmp1_;
	self->priv = AUDITIVE_GET_PRIVATE (self);
	_tmp0_ = g_main_loop_new (NULL, FALSE);
	self->priv->loop = _tmp0_;
	self->priv->resume_position = (gint64) 0;
	self->priv->screen_size = 0;
	self->priv->auto_start_number = -1;
	_tmp1_ = g_strdup ("");
	self->priv->auto_start_name = _tmp1_;
	self->ref_count = 1;
}


static void auditive_finalize (auditive* obj) {
	auditive * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_AUDITIVE, auditive);
	_g_main_loop_unref0 (self->priv->loop);
	_g_object_unref0 (self->priv->play);
	_g_object_unref0 (self->priv->bus);
	_g_free0 (self->priv->song_label);
	_g_free0 (self->priv->song_title);
	_g_free0 (self->priv->song_artist);
	_g_free0 (self->priv->song_album);
	_g_free0 (self->priv->song_short_file_name);
	_g_free0 (self->priv->auto_start_name);
}


GType auditive_get_type (void) {
	static volatile gsize auditive_type_id__volatile = 0;
	if (g_once_init_enter (&auditive_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_auditive_init, value_auditive_free_value, value_auditive_copy_value, value_auditive_peek_pointer, "p", value_auditive_collect_value, "p", value_auditive_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (auditiveClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) auditive_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (auditive), 0, (GInstanceInitFunc) auditive_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType auditive_type_id;
		auditive_type_id = g_type_register_fundamental (g_type_fundamental_next (), "auditive", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&auditive_type_id__volatile, auditive_type_id);
	}
	return auditive_type_id__volatile;
}


gpointer auditive_ref (gpointer instance) {
	auditive* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void auditive_unref (gpointer instance) {
	auditive* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		AUDITIVE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	auditive* _tmp0_;
	auditive* player;
	gchar* path = NULL;
	gboolean _tmp1_ = FALSE;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gboolean _tmp5_;
	auditive* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_ = NULL;
	gchar* _tmp23_;
	gst_init (&args_length1, &args);
	_tmp0_ = auditive_new ();
	player = _tmp0_;
	_tmp2_ = args;
	_tmp2__length1 = args_length1;
	if (_tmp2__length1 > 1) {
		gchar** _tmp3_;
		gint _tmp3__length1;
		const gchar* _tmp4_;
		_tmp3_ = args;
		_tmp3__length1 = args_length1;
		_tmp4_ = _tmp3_[1];
		_tmp1_ = g_strcmp0 (_tmp4_, "") != 0;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp5_ = _tmp1_;
	if (_tmp5_) {
		gchar** _tmp6_;
		gint _tmp6__length1;
		const gchar* _tmp7_;
		gchar _tmp8_ = '\0';
		_tmp6_ = args;
		_tmp6__length1 = args_length1;
		_tmp7_ = _tmp6_[1];
		_tmp8_ = string_get (_tmp7_, (glong) 0);
		if (_tmp8_ == '/') {
			gchar** _tmp9_;
			gint _tmp9__length1;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			_tmp9_ = args;
			_tmp9__length1 = args_length1;
			_tmp10_ = _tmp9_[1];
			_tmp11_ = g_strdup (_tmp10_);
			_g_free0 (path);
			path = _tmp11_;
		} else {
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_;
			gchar* _tmp14_;
			gchar* _tmp15_;
			gchar** _tmp16_;
			gint _tmp16__length1;
			const gchar* _tmp17_;
			gchar* _tmp18_;
			_tmp12_ = g_get_current_dir ();
			_tmp13_ = _tmp12_;
			_tmp14_ = g_strconcat (_tmp13_, "/", NULL);
			_tmp15_ = _tmp14_;
			_tmp16_ = args;
			_tmp16__length1 = args_length1;
			_tmp17_ = _tmp16_[1];
			_tmp18_ = g_strconcat (_tmp15_, _tmp17_, NULL);
			_g_free0 (path);
			path = _tmp18_;
			_g_free0 (_tmp15_);
			_g_free0 (_tmp13_);
		}
	} else {
		gchar* _tmp19_ = NULL;
		_tmp19_ = g_get_current_dir ();
		_g_free0 (path);
		path = _tmp19_;
	}
	_tmp20_ = player;
	_tmp21_ = path;
	_tmp22_ = remove_slashes (_tmp21_);
	_tmp23_ = _tmp22_;
	auditive_begin (_tmp20_, _tmp23_);
	_g_free0 (_tmp23_);
	result = 0;
	_g_free0 (path);
	_auditive_unref0 (player);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}



